<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <style>
      body {
        background-color: #404040;
        background-color: white;
        padding: 100px;
        width: 1000px;
        margin: auto;
        text-align: left;
        font-weight: 300;
        font-family: "Open Sans", sans-serif;
        color: #121212;
      }
      h1,
      h2,
      h3,
      h4 {
        font-family: "Source Sans Pro", sans-serif;
      }
      kbd {
        color: #121212;
      }
      blockquote {
        color: #888;
        border: 2px solid #333;
        padding: 10px;
        background-color: #ccc;
      }

      table.custom-tbl {
        border: 1px solid;
      }

      table.custom-tbl th {
        border: 1px solid;
        background-color: rgb(99, 209, 209);
      }

      table.custom-tbl td {
        border: 1px solid;
        background-color: #f1e686a8;
      }

      /* The alert message box */
      .alert {
        padding: 20px;
        background-color: #f44336; /* Red */
        color: white;
        margin-bottom: 15px;
      }

      /* The close button */
      .closebtn {
        margin-left: 15px;
        color: white;
        font-weight: bold;
        float: right;
        font-size: 22px;
        line-height: 20px;
        cursor: pointer;
        transition: 0.3s;
      }

      /* When moving the mouse over the close button */
      .closebtn:hover {
        color: black;
      }
    </style>

    <title>CS 184 Meshes</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <!-- Not using below due to lacking bold fontfaces -->
    <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro|Source+Sans+Pro:400,700" rel="stylesheet"> -->
    <link
      href="https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto+Slab|Roboto:300,400,500,700"
      rel="stylesheet"
    />

	  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	  </script>  
  </head>

  <body style="padding-top: 50px">
    <!-- <div align="middle">
      <img
        src="https://drive.google.com/uc?id=1DZQwwl_aq1IEPGaZFk4bAYzEJNrqHRN4"
        align="middle"
        width="1000vw"
      />
    </div> -->

    <h1 align="left">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
    <h1 align="left">Homework 2: Meshes</h1>
    <h2 align="left">Muc S'ojog: Bill Shao, Jonathan Pei</h2>
	<h3 align="left">Webpage Link: <a href="https://cal-cs184-student.github.io/hw-webpages-sp24-jonnypei/hw2/index.html">https://cal-cs184-student.github.io/hw-webpages-sp24-jonnypei/hw2/index.html</a></h2>
    <hr />

      <h2 align="left">Overview</h2>
      <p>
        In this assignment, we built Bezier curves and surfaces using the de Casteljau subdivision algorithm, developed triangle meshes modification methods, and implemented multiple loop subdivision methods. Our main takeaway was how intricate geometric modeling and mesh manipulation areâ€”we spent quite some time debugging the implementations for edge flip, edge split, and mesh upsampling. Nonetheless, we had tons of fun playing around with the tools we created! 
	  </p>

    <hr />
	<h2 align="middle">Section I: Bezier Curves and Surfaces</h1>
	<hr />

    <h2 align="left">Part 1: Bezier curves with 1D de Casteljau subdivision</h2>

    <p>
      <code>de Casteljau's algorithm Description:</code>  This algorithm works by using the points defining the 
      Bezier curve as guiding points, and calculates successive linear interpolations at these points until a 
      single point is found, which can then be varied by changing the <code>t</code> parameter to fully capture 
      points along the line. In this sense, de Casteljau's algorithm can be thought of as recursive, where the
       input is the current bounding points and the output is the next linearly-interpolated bounding points 
       until only 1 point remains. This recursive step was essentially the code in <code> evaluateStep </code>, 
       which used the helper function <code> lerp</code> on all consecutive pairs of verticies to go from n points to n-1 points.
       
       <pre>
        Vector2D lerp(Vector2D p1, Vector2D p2, double t) {
          return (1 - t) * p1 + t * p2;
        }
      </pre>
      <pre>
        BezierCurve::evaluateStep(std::vector<Vector2D> const &points) {
          auto interpolatedpoints = vector<Vector2D>();
          for (int i = 0; i < points.size() - 1; i++) {
            interpolatedpoints.push_back(lerp(points[i], points[i + 1], t));
          }
        
          return interpolatedpoints;
        }
      </pre>
    

    </p>

    <div align=";middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/download.jpeg" align="middle" width="500vw" />
            <figcaption>Bezier Curve of 6 points with successive evaluateStep function calls at ~<code>t = 0.5</code>. </figcaption>
          </td>
        </tr>
      </table>
    </div>
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/lerp5wline.png" align="middle" width="300vw" />
            <figcaption>Final Rendered Curve</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/differentCurve.png" align="middle" width="300vw" />
            <figcaption>Slightly different curve with lower <code>t.</code></figcaption>
          </td>
        </tr>
      </table>
    </div>

	<h2 align="left">Part 2: Bezier surfaces with separable 1D de Casteljau</h2>

  <p>
    <code>How de Casteljau algorithm extends to Bezier surfaces:</code> Bezier surfaces 
    can be imagined as taking multiple 1D curves along the same axis, and then using those resulting 
    points from the successive curves to perform one last Bezier curve evaluation. In terms of the inputs,
     the 2D array controlPoints is treated as rows of 1D curves and evaluated row by row on the parameter 
     <code>u</code>, which is equivalent to <code>t</code>. This generates 1 final list of points called <code>interpolationsatu</code>, 
     which is evaluated on parameter <code>v</code> to get the final point on the patch. Interpretation wise,
     varying u and v can then be thought of as traversing along different x,y positions of the patch. Implementation-wise, 
     the only major addition was the function <code>evaluate1D</code>, which actually wrapped and recursively called <code>evaluateStep.</code>
  </p>
  <pre>

    Vector3D BezierPatch::evaluate(double u, double v) const {
      auto interpolationsatu = vector<Vector3D>();
      unsigned int n = controlPoints.size();
      for (int i = 0; i < n; i++) {
        interpolationsatu.push_back(evaluate1D(controlPoints[i], u));
      }
    
      return evaluate1D(interpolationsatu, v);
    }
  </pre>
  <pre>
    Vector3D BezierPatch::evaluate1D(std::vector<Vector3D> const &points,
      double t) const {
      // TODO Part 2.
      if (points.size() == 1) {
      return points[0];
      }
      auto currInterp = evaluateStep(points, t);
      while (currInterp.size() > 1) {
      currInterp = evaluateStep(currInterp, t);
      }

      return currInterp[0];
    }
  </pre>


  <div align="middle">
    <table style="width: 100%">
      <tr align="center">
        <td>
          <img src="images/teapot.png" align="middle" width="500vw" />
          <figcaption>Render of teapot.dae </figcaption>
        </td>
      </tr>
    </table>
  </div>
	
	<hr />
	<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h1>
	<hr />

	<h2 align="left">Part 3: Area-weighted vertex normals</h2>

  <p>
    <code>Implementation of area-weighted vertex normals: </code>  The code to implement the area-weighted vertex normal was split into 2 major components.
    The first was collecting all verticies necessary to generate faces to average across, and the second was the perform the actual averaging process.
    To collect the verticies, the modified example <code>printNeighbourPositions</code> function was used as shown below. 
  </p>
  <pre>
    HalfedgeCIter h = halfedge();
    Vector3D originPoint = h->vertex()->position;
    auto verticies = vector<Vector3D>();
    do {
      HalfedgeCIter h_twin = h->twin(); // get the opposite half-edge
      VertexCIter v =
          h_twin->vertex(); // vertex is the 'source' of the half-edge, so
                            // h->vertex() is v, whereas h_twin->vertex()
                            // is the neighboring vertex
      verticies.push_back(v->position);
      h = h_twin->next(); // move to the next outgoing half-edge of the vertex
    } while (h != halfedge());
  </pre>
  <p>
    This code snippet iterates through all neighboring verticies and stores them into the <code>verticies</code> vector. 
    Then, creating each face can be conceptually seen as taking <code>verticies[i]</code>, <code>verticies[i+1]</code>, and the original vertex.
    This is because each face must border the original vertex, and the other two edges must be adjacent to each other. 
    Finally, the cross-product was used to find the normal vector, which was subtracted from a total vector and normalized at the end.
    It was subtracted since we were having issues with a very dark shading, meaning the vector was pointing inwards on the mesh rather than outwards!
    Since the length of each normal vector depends on the length of the face defining vectors used, the resulting vector is natually area-weighted. 
    
    <pre>
      for (int i = 0; i < verticies.size() - 1; i++) {
        auto vec1 = verticies[i] - originPoint;
        auto vec2 = verticies[i + 1] - originPoint;
        auto normvec = -cross(vec1, vec2);
        normalvec += normvec;
      }
    
      return normalvec.unit();
    </pre>
  </p>
  

  <div align="middle">
    <table style="width: 100%">
      <tr align="center">
        <td>
          <img src="images/teapot.png" align="middle" width="400vw" />
          <figcaption>Render of teapot.dae with flat shading.</figcaption>
        </td>
        <td>
          <img src="images/teapotphong.png" align="middle" width="400vw" />
          <figcaption>Render of teapot.dae with phong shading.</figcaption>
        </td>
      </tr>
    </table>
  </div>

	<h2 align="left">Part 4: Edge flip</h2>

  <p>
    Our implementation of an edge flip consists of the following steps:

    <ol>
      <li><b>Boundary Check:</b></li>
      <li><b>Mesh Labeling:</b></li>
      <li><b>Re-assign half-edges:</b></li>
      <li><b>Re-assign vertices:</b></li>
      <li><b>Re-assign faces:</b></li>
    </ol>

  We now display some screenshots of the teapot before and after some edge flips:
    </p>

    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/[TODO].png" align="middle" width="300vw" />
            <figcaption>Teapot before</figcaption>
          </td>
          <td>
            <img src="images/[TODO].png" align="middle" width="300vw" />
            <figcaption>Teapot after 1 edge flip</figcaption>
          </td>
          <td>
            <img src="images/[TODO].png" align="middle" width="300vw" />
            <figcaption>Teapot after multiple edge flips</figcaption>
          </td>
        </tr>
      </table>
    </div>

    <p>
      Our debugging journey wasn't too eventful; our initial implementation simply didn't account for all the pointers we had to change. Having an organized diagram of our labeled half-edges, edges, vertices, and faces really helped us pinpoint the pointer bugs.
    </p>


	<h2 align="left">Part 5: Edge split</h2>

  <p>
    Our implementation of an edge split consists of the following steps:
    <ol>
      <li><b>Boundary Check:</b></li>
      <li><b>Mesh Labeling:</b></li>
      <li><b>Mesh Creation:</b></li>
      <li><b>Re-assign half-edges:</b></li>
      <li><b>Re-assign vertices:</b></li>
      <li><b>Re-assign faces:</b></li>
    </ol>

    We now display some screenshots of the teapot before and after some edge operations:
  </p>

  <div align="middle">
    <table style="width: 100%">
      <tr align="center">
        <td>
          <img src="images/[TODO].png" align="middle" width="300vw" />
          <figcaption>Teapot before</figcaption>
        </td>
        <td>
          <img src="images/[TODO].png" align="middle" width="300vw" />
          <figcaption>Teapot after 1 edge split</figcaption>
        </td>
        <td>
          <img src="images/[TODO].png" align="middle" width="300vw" />
          <figcaption>Teapot after multiple edge splits</figcaption>
        </td>
        <td>
          <img src="images/[TODO].png" align="middle" width="300vw" />
          <figcaption>Teapot after multiple edge flips and splits</figcaption>
        </td>
      </tr>
    </table>
  </div>

  <p>
    Our debugging journey mainly consisted of the following events:
    <ol>
      <li>Missing edge reassignments, which caused a bunch of seg-faults.</li>
      <li>Some half-edges being assigned to the wrong vertices, which produced black spots and missing faces.</li>
      <li>Forgetting to reassign pointers for the original face (not the 3 new faces).</li>
    </ol>
  </p>

  <h3 align="left">[Extra Credit] Support for Splitting on Boundary Edges</h3>

	<h2 align="left">Part 6: Loop subdivision for mesh upsampling</h2>

  <h3 align="left">Implementation Details</h3>

  <p>
    Our implementation of loop subdivision consists of the following steps:

    <ol>
      <li><b>Compute new positions of old vertices in the mesh:</b></li>
      <pre>
for (VertexIter v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++) {
  v->isNew = false;
  double u = 3.0 / (8 * v->degree());
  if (v->degree() == 3) {
    u = 3.0 / 16;
  }
  v->newPosition = (1 - v->degree() * u) * v->position + u * getOriginalNeighborPosSum(v);
}
      </pre>
      <li><b>Compute new positions of new vertices to be created via splits:</b></li>
      <pre>
for (EdgeIter e = mesh.edgesBegin(); e != mesh.edgesEnd(); e++) {
  e->isNew = false;
  e->visited = false;

  Vector3D A = e->halfedge()->vertex()->position;
  Vector3D B = e->halfedge()->twin()->vertex()->position;
  Vector3D C = e->halfedge()->next()->next()->vertex()->position;
  Vector3D D = e->halfedge()->twin()->next()->next()->vertex()->position;

  e->newPosition = 3.0 / 8 * (A + B) + 1.0 / 8 * (C + D);
}
      </pre>
      <li><b>Split all the old edges in the mesh:</b></li>
      <pre>
EdgeIter e = mesh.edgesBegin();
while (e != mesh.edgesEnd()) {
  EdgeIter nextEdge = e;
  nextEdge++;

  if (!e->visited) {
    VertexIter v = mesh.splitEdge(e);
    v->newPosition = e->newPosition;
  }

  e = nextEdge;
}
      </pre>
      <li><b>Flip all the new edges (generated via splits) that connect an old vertex to a new vertex:</b></li>
      <pre>
e = mesh.edgesBegin();
while (e != mesh.edgesEnd()) {
  EdgeIter nextEdge = e;
  nextEdge++;

  if (e->isNew && e->halfedge()->vertex()->isNew !=
                      e->halfedge()->twin()->vertex()->isNew) {
    mesh.flipEdge(e);
  }

  e = nextEdge;
}
      </pre>
      <li><b>Update the positions of all vertices.</b></li>
      <pre>
for (VertexIter v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++) {
  v->position = v->newPosition;
}
      </pre>
    </ol>
  </p>

  <h3>Mesh Behavior After Loop Subdivision</h3>

  <h3>Symmetric Subdivision on Cube</h3>

  <h3>[Extra Credit] Support for Meshes with Boundaries </h3>
 
  <h3>[Extra Credit] \(\sqrt{3}\)-Subdivision</h3>
	
	<hr />
	<h2 align="middle">Section III: Potential Extra Credit - Art Competition: Model something Creative!</h1>
  </html>
